function numgrad = computeNumGrad(func, nn)
%COMPUTENUMERICALGRADIENT Computes the gradient using "finite differences"
%and gives us a numerical estimate of the gradient.
%   numgrad = COMPUTENUMERICALGRADIENT(J, theta) computes the numerical
%   gradient of the function J around theta. Calling y = J(theta) should
%   return the function value at theta.

% Notes: The following code implements numerical gradient checking, and 
%        returns the numerical gradient.It sets numgrad(i) to (a numerical 
%        approximation of) the partial derivative of J with respect to the 
%        i-th input argument, evaluated at theta. (i.e., numgrad(i) should 
%        be the (approximately) the partial derivative of J with respect 
%        to theta(i).)
%       
nn1 = nn;
nn2 = nn;
%numerical gradient
cnt = 0;
for i = 1: nn.n-1
    cnt = cnt + nn.size(i+1)*(nn.size(i)+1);
end
numgrad = zeros(cnt,1);
perturb = zeros(cnt,1);
eps = 1e-4;
pos = 0;
for i = 1 : nn.n-1
    for k = 1 : nn.size{i}+1
        for j = 1 : nn.size{i+1}
            nn1.W{i}(j,k) = nn.W{i}(j,k) - eps;
            nn2.W{i}(j,k) = nn.W{i}(j,k) + eps;
            nn1 = func(nn1);
            nn2 = func(nn2);
            
        end
    end
end
for p = 1:cnt
    % Set perturbation vector
    perturb(p) = e;
    nn1 = func(nn1);
    nn2 = func(nn2);
    % Compute Numerical Gradient
    numgrad(p) = (nn2.L - nn1.L) / (2*e);
    perturb(p) = 0;
end

end
